---
phase: 17-performance-foundation
plan: 02
type: execute
wave: 2
depends_on: ["17-01"]
files_modified:
  - components/skeletons/DashboardSkeleton.tsx
  - components/skeletons/HighlightsSkeleton.tsx
  - components/skeletons/StudySkeleton.tsx
  - components/skeletons/SettingsSkeleton.tsx
  - pages/Dashboard.tsx
  - pages/Highlights.tsx
  - pages/Study.tsx
  - pages/Settings.tsx
autonomous: true
requirements: [PERF-02, PERF-03]
must_haves:
  truths:
    - "User sees a high-fidelity skeleton on Dashboard while data loads (no text-only loading state)"
    - "User sees a high-fidelity skeleton on Highlights while data loads"
    - "User sees a high-fidelity skeleton on Study while data loads"
    - "User sees a high-fidelity skeleton on Settings while data loads"
    - "Skeletons match exact page layouts with zero layout shift when content loads"
    - "If data loads in <200ms, no skeleton flashes (delay prevents flicker)"
    - "Content fades in with 150ms transition after skeleton"
  artifacts:
    - path: "components/skeletons/DashboardSkeleton.tsx"
      provides: "High-fidelity Dashboard skeleton layout"
      exports: ["DashboardSkeleton"]
    - path: "components/skeletons/HighlightsSkeleton.tsx"
      provides: "High-fidelity Highlights skeleton layout"
      exports: ["HighlightsSkeleton"]
    - path: "components/skeletons/StudySkeleton.tsx"
      provides: "High-fidelity Study skeleton layout"
      exports: ["StudySkeleton"]
    - path: "components/skeletons/SettingsSkeleton.tsx"
      provides: "High-fidelity Settings skeleton layout"
      exports: ["SettingsSkeleton"]
  key_links:
    - from: "pages/Dashboard.tsx"
      to: "components/skeletons/DashboardSkeleton.tsx"
      via: "useSkeletonDelay hook controlling visibility"
      pattern: "useSkeletonDelay.*isLoaded"
    - from: "pages/Highlights.tsx"
      to: "components/skeletons/HighlightsSkeleton.tsx"
      via: "useSkeletonDelay hook controlling visibility"
      pattern: "useSkeletonDelay.*isLoaded"
    - from: "pages/Study.tsx"
      to: "components/skeletons/StudySkeleton.tsx"
      via: "useSkeletonDelay hook controlling visibility"
      pattern: "useSkeletonDelay.*isLoaded"
    - from: "pages/Settings.tsx"
      to: "components/skeletons/SettingsSkeleton.tsx"
      via: "useSkeletonDelay hook controlling visibility"
      pattern: "useSkeletonDelay.*isLoaded"
---

<objective>
Create high-fidelity skeleton components for all four data-fetching pages and wire them into the loading flow using the useSkeletonDelay hook from Plan 01.

Purpose: Users see layout-matching skeleton placeholders instead of text loading indicators, providing zero layout shift and professional perceived performance.
Output: Four skeleton components + updated pages using useSkeletonDelay for 200ms delay / 300ms min / 150ms fade transitions.
</objective>

<execution_context>
@C:/Users/ADMIN/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ADMIN/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-performance-foundation/17-RESEARCH.md
@.planning/phases/17-performance-foundation/17-01-SUMMARY.md

@components/ui/skeleton.tsx
@hooks/useSkeletonDelay.ts
@pages/Dashboard.tsx
@pages/Highlights.tsx
@pages/Study.tsx
@pages/Settings.tsx
@lbp_diretrizes/design-system-guide.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create skeleton components for Dashboard and Highlights</name>
  <files>
    components/skeletons/DashboardSkeleton.tsx
    components/skeletons/HighlightsSkeleton.tsx
  </files>
  <action>
    Create `components/skeletons/` directory.

    **DashboardSkeleton.tsx** — Must mirror the exact Dashboard layout. Read the full `pages/Dashboard.tsx` to understand the actual layout, then create skeleton blocks matching each section's dimensions:
    - PageHeader area (title + subtitle + optional action button)
    - Quick Study CTA banner (if present)
    - KPI stat cards grid (2 cols mobile, 4 cols desktop — match `grid-cols-2 sm:grid-cols-4 gap-sm`)
    - Heatmap area
    - Top books / chart area (bottom section)
    - Use `Skeleton` primitive from `components/ui/skeleton.tsx`
    - Use semantic spacing tokens: `p-md sm:p-lg`, `mb-lg`, `gap-sm`
    - All skeleton blocks use `bg-muted animate-pulse rounded-md` (via Skeleton component)
    - Heights MUST match actual rendered element heights to prevent layout shift

    **HighlightsSkeleton.tsx** — Read full `pages/Highlights.tsx` to understand layout:
    - PageHeader area with title
    - Search bar + filter controls toolbar
    - Table header row (skeleton rectangles for each column header)
    - 8-10 table body rows (skeleton blocks mimicking text in each column)
    - Use consistent heights matching actual table row heights
    - Match the page's responsive behavior

    Both components:
    - Import `Skeleton` from `../ui/skeleton`
    - Export as named exports
    - Use semantic tokens from design system (bg-muted, border-border, gap-sm, p-md, etc.)
    - No data dependencies — pure presentational
  </action>
  <verify>
    - `npm run build` completes without errors
    - Both files export their skeleton components
    - No data imports (pure layout components)
  </verify>
  <done>
    DashboardSkeleton and HighlightsSkeleton exist as high-fidelity layout mirrors of their respective pages, using the Skeleton primitive with semantic tokens.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create skeleton components for Study and Settings, wire all skeletons into pages</name>
  <files>
    components/skeletons/StudySkeleton.tsx
    components/skeletons/SettingsSkeleton.tsx
    pages/Dashboard.tsx
    pages/Highlights.tsx
    pages/Study.tsx
    pages/Settings.tsx
  </files>
  <action>
    **StudySkeleton.tsx** — Read full `pages/Study.tsx` to understand layout:
    - PageHeader area
    - Heatmap placeholder area (if heatmap is shown on Study page)
    - Deck table: table header + 4-5 deck rows (book name, cards due, progress bar shapes)
    - Match actual table structure and spacing

    **SettingsSkeleton.tsx** — Read full `pages/Settings.tsx` to understand layout:
    - PageHeader area
    - Tab bar (4 tab buttons in a row)
    - Tab content area: a generic content skeleton (form fields, upload area shape)
    - Since Settings loads UI immediately but data populates async, show a generic form-like skeleton

    **Wire all 4 skeletons into their pages using useSkeletonDelay:**

    For each page (Dashboard, Highlights, Study, Settings):

    1. Import the skeleton component and useSkeletonDelay hook:
       ```typescript
       import { DashboardSkeleton } from '../components/skeletons/DashboardSkeleton'
       import { useSkeletonDelay } from '../hooks/useSkeletonDelay'
       ```

    2. Add the hook call near the top of the component:
       ```typescript
       const { showSkeleton, showContent } = useSkeletonDelay(isLoaded)
       ```

    3. Replace the existing loading guard. For Dashboard and Study, replace the `if (!isLoaded)` block:
       ```typescript
       // BEFORE:
       if (!isLoaded) {
         return (
           <div className="flex items-center justify-center h-full text-muted-foreground">
             {t('loading', { ns: 'common' })}
           </div>
         );
       }

       // AFTER:
       if (showSkeleton || !isLoaded) {
         return <DashboardSkeleton />
       }
       ```

    4. For Highlights — currently has NO `isLoaded` guard. Add one:
       - Ensure `isLoaded` is destructured from `useStore()` (add it if missing)
       - Add the skeleton guard at the top of the component body:
       ```typescript
       const { showSkeleton, showContent } = useSkeletonDelay(isLoaded)
       if (showSkeleton || !isLoaded) {
         return <HighlightsSkeleton />
       }
       ```

    5. For Settings — currently has NO `isLoaded` guard. Add one:
       - Ensure `isLoaded` is destructured from `useStore()` (add it if missing)
       - Add the skeleton guard:
       ```typescript
       const { showSkeleton, showContent } = useSkeletonDelay(isLoaded)
       if (showSkeleton || !isLoaded) {
         return <SettingsSkeleton />
       }
       ```

    6. Wrap the main content of each page with the fade-in transition:
       ```tsx
       return (
         <div className={showContent ? 'animate-in fade-in duration-150' : 'opacity-0'}>
           {/* existing page content */}
         </div>
       )
       ```
       The `animate-in fade-in` classes are from `tailwindcss-animate` (already installed).
       IMPORTANT: The wrapping div should not interfere with existing layout — use a fragment or ensure no extra margin/padding.

    7. CRITICAL: The `showSkeleton || !isLoaded` condition ensures:
       - Before 200ms: `!isLoaded` is true, `showSkeleton` is false — skeleton shows (because !isLoaded is the fallback)
       - Actually wait — we want NO skeleton before 200ms. Re-read the locked decision:
         "Brief delay (~200ms) before showing skeleton — stay on current page to avoid flash for fast loads"
       - This means: for the FIRST 200ms, show NOTHING (stay on previous page via Suspense). After 200ms, show skeleton.
       - The correct guard is: `if (!isLoaded && showSkeleton) return <Skeleton />`
       - But we also need the page to return something when `!isLoaded && !showSkeleton` (the 0-200ms window) — return null or the Suspense fallback handles this.
       - SIMPLIFICATION: Since Suspense wraps route content in App.tsx and `PageLoadingFallback` is the Suspense fallback, during the first 200ms the Suspense fallback (spinner) shows. This is acceptable — the 200ms delay in the hook prevents the skeleton from appearing for fast loads. The actual pattern:
         ```typescript
         if (!isLoaded) {
           if (showSkeleton) return <DashboardSkeleton />
           return null  // Suspense fallback handles this brief window
         }
         ```
       - And for content fade: when `isLoaded` becomes true, `showContent` drives the animation.
  </action>
  <verify>
    - `npm run build` completes without errors
    - All 4 pages import and use their skeleton component
    - All 4 pages use `useSkeletonDelay` hook
    - Dashboard: old text loading guard is replaced
    - Study: old text loading guard is replaced
    - Highlights: new `isLoaded` guard added with skeleton
    - Settings: new `isLoaded` guard added with skeleton
    - Dev server shows skeleton on throttled network (Chrome DevTools > Network > Slow 3G, clear cache, reload)
  </verify>
  <done>
    All four data-fetching pages show high-fidelity skeleton loaders during data loading with 200ms delay (no flash on fast loads), 300ms minimum display (no flicker), and 150ms content fade-in. No text-only loading states remain.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` succeeds
2. Open dev server, throttle network to Slow 3G in Chrome DevTools
3. Navigate to Dashboard — should see DashboardSkeleton, then content fades in
4. Navigate to Highlights — should see HighlightsSkeleton, then content fades in
5. Navigate to Study — should see StudySkeleton, then content fades in
6. Navigate to Settings — should see SettingsSkeleton, then content fades in
7. On fast connection (localhost), skeletons should NOT flash (200ms delay prevents it)
8. No layout shift when content replaces skeleton
</verification>

<success_criteria>
- All 4 pages (Dashboard, Highlights, Study, Settings) show skeleton loaders during data load
- Skeletons match page layout with zero visible layout shift on content load
- 200ms delay prevents skeleton flash on fast connections
- Content fades in smoothly (150ms transition)
- No text-only "Carregando..." loading states remain in any of the 4 pages
</success_criteria>

<output>
After completion, create `.planning/phases/17-performance-foundation/17-02-SUMMARY.md`
</output>

---
phase: 17-performance-foundation
plan: 02
type: execute
wave: 2
depends_on: ["17-01"]
files_modified:
  - components/skeletons/DashboardSkeleton.tsx
  - components/skeletons/HighlightsSkeleton.tsx
  - components/skeletons/StudySkeleton.tsx
  - components/skeletons/SettingsSkeleton.tsx
  - pages/Dashboard.tsx
  - pages/Highlights.tsx
  - pages/Study.tsx
  - pages/Settings.tsx
autonomous: true
requirements: [PERF-02, PERF-03]
must_haves:
  truths:
    - "User sees a high-fidelity skeleton on Dashboard while data loads (no text-only loading state)"
    - "User sees a high-fidelity skeleton on Highlights while data loads"
    - "User sees a high-fidelity skeleton on Study while data loads"
    - "User sees a high-fidelity skeleton on Settings while data loads"
    - "Skeletons match exact page layouts with zero layout shift when content loads"
    - "If data loads in <200ms, no skeleton flashes (delay prevents flicker)"
    - "Content fades in with 150ms transition after skeleton"
  artifacts:
    - path: "components/skeletons/DashboardSkeleton.tsx"
      provides: "High-fidelity Dashboard skeleton layout"
      exports: ["DashboardSkeleton"]
    - path: "components/skeletons/HighlightsSkeleton.tsx"
      provides: "High-fidelity Highlights skeleton layout"
      exports: ["HighlightsSkeleton"]
    - path: "components/skeletons/StudySkeleton.tsx"
      provides: "High-fidelity Study skeleton layout"
      exports: ["StudySkeleton"]
    - path: "components/skeletons/SettingsSkeleton.tsx"
      provides: "High-fidelity Settings skeleton layout"
      exports: ["SettingsSkeleton"]
  key_links:
    - from: "pages/Dashboard.tsx"
      to: "components/skeletons/DashboardSkeleton.tsx"
      via: "useSkeletonDelay hook controlling visibility"
      pattern: "useSkeletonDelay.*isLoaded"
    - from: "pages/Highlights.tsx"
      to: "components/skeletons/HighlightsSkeleton.tsx"
      via: "useSkeletonDelay hook controlling visibility"
      pattern: "useSkeletonDelay.*isLoaded"
    - from: "pages/Study.tsx"
      to: "components/skeletons/StudySkeleton.tsx"
      via: "useSkeletonDelay hook controlling visibility"
      pattern: "useSkeletonDelay.*isLoaded"
    - from: "pages/Settings.tsx"
      to: "components/skeletons/SettingsSkeleton.tsx"
      via: "useSkeletonDelay hook controlling visibility"
      pattern: "useSkeletonDelay.*isLoaded"
---

<objective>
Create high-fidelity skeleton components for all four data-fetching pages and wire them into the loading flow using the useSkeletonDelay hook from Plan 01.

Purpose: Users see layout-matching skeleton placeholders instead of text loading indicators, providing zero layout shift and professional perceived performance.
Output: Four skeleton components + updated pages using useSkeletonDelay for 200ms delay / 300ms min / 150ms fade transitions.
</objective>

<execution_context>
@C:/Users/ADMIN/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ADMIN/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-performance-foundation/17-RESEARCH.md
@.planning/phases/17-performance-foundation/17-01-SUMMARY.md

@components/ui/skeleton.tsx
@hooks/useSkeletonDelay.ts
@pages/Dashboard.tsx
@pages/Highlights.tsx
@pages/Study.tsx
@pages/Settings.tsx
@lbp_diretrizes/design-system-guide.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create skeleton components for Dashboard and Highlights</name>
  <files>
    components/skeletons/DashboardSkeleton.tsx
    components/skeletons/HighlightsSkeleton.tsx
  </files>
  <action>
    Create `components/skeletons/` directory.

    **DashboardSkeleton.tsx** — Must mirror the exact Dashboard layout. Read the full `pages/Dashboard.tsx` to understand the actual layout, then create skeleton blocks matching each section's dimensions:
    - PageHeader area (title + subtitle + optional action button)
    - Quick Study CTA banner (if present)
    - KPI stat cards grid (2 cols mobile, 4 cols desktop — match `grid-cols-2 sm:grid-cols-4 gap-sm`)
    - Heatmap area
    - Top books / chart area (bottom section)
    - Use `Skeleton` primitive from `components/ui/skeleton.tsx`
    - Use semantic spacing tokens: `p-md sm:p-lg`, `mb-lg`, `gap-sm`
    - All skeleton blocks use `bg-muted animate-pulse rounded-md` (via Skeleton component)
    - Heights MUST match actual rendered element heights to prevent layout shift

    **HighlightsSkeleton.tsx** — Read full `pages/Highlights.tsx` to understand layout:
    - PageHeader area with title
    - Search bar + filter controls toolbar
    - Table header row (skeleton rectangles for each column header)
    - 8-10 table body rows (skeleton blocks mimicking text in each column)
    - Use consistent heights matching actual table row heights
    - Match the page's responsive behavior

    Both components:
    - Import `Skeleton` from `../ui/skeleton`
    - Export as named exports
    - Use semantic tokens from design system (bg-muted, border-border, gap-sm, p-md, etc.)
    - No data dependencies — pure presentational
  </action>
  <verify>
    - `npm run build` completes without errors
    - Both files export their skeleton components
    - No data imports (pure layout components)
  </verify>
  <done>
    DashboardSkeleton and HighlightsSkeleton exist as high-fidelity layout mirrors of their respective pages, using the Skeleton primitive with semantic tokens.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create skeleton components for Study and Settings, wire all skeletons into pages</name>
  <files>
    components/skeletons/StudySkeleton.tsx
    components/skeletons/SettingsSkeleton.tsx
    pages/Dashboard.tsx
    pages/Highlights.tsx
    pages/Study.tsx
    pages/Settings.tsx
  </files>
  <action>
    **StudySkeleton.tsx** — Read full `pages/Study.tsx` to understand layout:
    - PageHeader area
    - Heatmap placeholder area (if heatmap is shown on Study page)
    - Deck table: table header + 4-5 deck rows (book name, cards due, progress bar shapes)
    - Match actual table structure and spacing

    **SettingsSkeleton.tsx** — Read full `pages/Settings.tsx` to understand layout:
    - PageHeader area
    - Tab bar (4 tab buttons in a row)
    - Tab content area: a generic content skeleton (form fields, upload area shape)
    - Since Settings loads UI immediately but data populates async, show a generic form-like skeleton

    **Wire all 4 skeletons into their pages using useSkeletonDelay:**

    IMPORTANT — Loading guard pattern clarification:

    There are TWO loading boundaries in the app, and they serve different purposes:

    a) **Route-level Suspense** (in App.tsx): Handles the "stay on current page" locked decision.
       While the route JS bundle is loading (code-splitting), React Suspense keeps the previous
       page visible. The 200ms delay decision applies HERE — users see the current page while
       the next route's chunk downloads. This is already handled by Suspense + lazy loading.

    b) **In-page data loading** (in each page component): Once the page component has mounted
       (JS loaded), the component is rendering and MUST return JSX. The store's `isLoaded` flag
       indicates whether Supabase data is ready. During this window, the page should show its
       skeleton IMMEDIATELY — there is no "stay on current page" concept here because the page
       IS the current page. The useSkeletonDelay hook serves two purposes at this level:
       - Enforces minimum 300ms skeleton display (prevents flicker if data loads in 250ms)
       - Controls the 150ms content fade-in transition

    The correct pattern for ALL pages:

    ```typescript
    // Show skeleton immediately when data isn't loaded.
    // showSkeleton stays true for at least 300ms after it activates (min display).
    // Once data loads AND min display is met, showContent triggers fade-in.
    if (!isLoaded || showSkeleton) {
      return <DashboardSkeleton />
    }
    ```

    This means: skeleton appears as soon as the page mounts (if data isn't ready), stays
    for at least 300ms, then content fades in. No blank screen, no flash. The 200ms
    delay from useSkeletonDelay is NOT used for in-page guards — it only matters if we
    wanted a pre-skeleton blank window (we don't at the page level).

    For each page (Dashboard, Highlights, Study, Settings):

    1. Import the skeleton component and useSkeletonDelay hook:
       ```typescript
       import { DashboardSkeleton } from '../components/skeletons/DashboardSkeleton'
       import { useSkeletonDelay } from '../hooks/useSkeletonDelay'
       ```

    2. Add the hook call near the top of the component:
       ```typescript
       const { showSkeleton, showContent } = useSkeletonDelay(isLoaded)
       ```

    3. Replace the existing loading guard. For Dashboard and Study, replace the `if (!isLoaded)` block:
       ```typescript
       // BEFORE:
       if (!isLoaded) {
         return (
           <div className="flex items-center justify-center h-full text-muted-foreground">
             {t('loading', { ns: 'common' })}
           </div>
         );
       }

       // AFTER:
       if (!isLoaded || showSkeleton) {
         return <DashboardSkeleton />
       }
       ```

    4. For Highlights — currently has NO `isLoaded` guard. Add one:
       - Ensure `isLoaded` is destructured from `useStore()` (add it if missing)
       - Add the skeleton guard at the top of the component body:
       ```typescript
       const { showSkeleton, showContent } = useSkeletonDelay(isLoaded)
       if (!isLoaded || showSkeleton) {
         return <HighlightsSkeleton />
       }
       ```

    5. For Settings — currently has NO `isLoaded` guard. Add one:
       - Ensure `isLoaded` is destructured from `useStore()` (add it if missing)
       - Add the skeleton guard:
       ```typescript
       const { showSkeleton, showContent } = useSkeletonDelay(isLoaded)
       if (!isLoaded || showSkeleton) {
         return <SettingsSkeleton />
       }
       ```

    6. Wrap the main content of each page with the fade-in transition:
       ```tsx
       return (
         <div className={showContent ? 'animate-in fade-in duration-150' : 'opacity-0'}>
           {/* existing page content */}
         </div>
       )
       ```
       The `animate-in fade-in` classes are from `tailwindcss-animate` (already installed).
       IMPORTANT: The wrapping div should not interfere with existing layout — use a fragment or ensure no extra margin/padding.
  </action>
  <verify>
    - `npm run build` completes without errors
    - All 4 pages import and use their skeleton component
    - All 4 pages use `useSkeletonDelay` hook
    - Dashboard: old text loading guard is replaced
    - Study: old text loading guard is replaced
    - Highlights: new `isLoaded` guard added with skeleton
    - Settings: new `isLoaded` guard added with skeleton
    - Dev server shows skeleton on throttled network (Chrome DevTools > Network > Slow 3G, clear cache, reload)
  </verify>
  <done>
    All four data-fetching pages show high-fidelity skeleton loaders during data loading with 200ms delay (no flash on fast loads), 300ms minimum display (no flicker), and 150ms content fade-in. No text-only loading states remain.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` succeeds
2. Open dev server, throttle network to Slow 3G in Chrome DevTools
3. Navigate to Dashboard — should see DashboardSkeleton, then content fades in
4. Navigate to Highlights — should see HighlightsSkeleton, then content fades in
5. Navigate to Study — should see StudySkeleton, then content fades in
6. Navigate to Settings — should see SettingsSkeleton, then content fades in
7. On fast connection (localhost), skeletons should NOT flash (200ms delay prevents it)
8. No layout shift when content replaces skeleton
</verification>

<success_criteria>
- All 4 pages (Dashboard, Highlights, Study, Settings) show skeleton loaders during data load
- Skeletons match page layout with zero visible layout shift on content load
- 200ms delay prevents skeleton flash on fast connections
- Content fades in smoothly (150ms transition)
- No text-only "Carregando..." loading states remain in any of the 4 pages
</success_criteria>

<output>
After completion, create `.planning/phases/17-performance-foundation/17-02-SUMMARY.md`
</output>

---
phase: 17-performance-foundation
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - vite.config.ts
  - sw.ts
  - hooks/useOnlineStatus.ts
  - components/Sidebar.tsx
autonomous: true
requirements: [SW-01, SW-02]
must_haves:
  truths:
    - "PWA uses a custom service worker (injectManifest strategy, not generateSW)"
    - "App shell is precached and loads offline"
    - "Supabase API requests use NetworkFirst caching strategy"
    - "Review log POST requests are queued when offline and replayed on reconnection"
    - "Offline status is indicated in the sidebar"
    - "Build succeeds and produces a service worker file"
  artifacts:
    - path: "sw.ts"
      provides: "Custom service worker with precaching, runtime caching, and background sync"
      contains: "precacheAndRoute"
    - path: "hooks/useOnlineStatus.ts"
      provides: "Online/offline detection hook"
      exports: ["useOnlineStatus"]
    - path: "vite.config.ts"
      provides: "Updated PWA config with injectManifest strategy"
      contains: "strategies: 'injectManifest'"
  key_links:
    - from: "vite.config.ts"
      to: "sw.ts"
      via: "injectManifest config points to sw.ts"
      pattern: "filename.*sw\\.ts"
    - from: "sw.ts"
      to: "workbox-precaching"
      via: "precacheAndRoute for app shell"
      pattern: "precacheAndRoute.*__WB_MANIFEST"
    - from: "sw.ts"
      to: "workbox-background-sync"
      via: "BackgroundSyncPlugin for offline reviews"
      pattern: "BackgroundSyncPlugin.*review"
    - from: "components/Sidebar.tsx"
      to: "hooks/useOnlineStatus.ts"
      via: "import hook to show offline badge"
      pattern: "useOnlineStatus"
---

<objective>
Migrate the PWA service worker from auto-generated (generateSW) to custom (injectManifest), enabling future push notification handlers, and add offline review queuing with a subtle offline indicator.

Purpose: The custom service worker is required for Phase 18 (push notifications) and enables offline study with background sync for review submissions.
Output: Custom sw.ts with precaching + runtime caching + background sync, updated vite.config.ts, offline indicator in sidebar.
</objective>

<execution_context>
@C:/Users/ADMIN/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ADMIN/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-performance-foundation/17-RESEARCH.md

@vite.config.ts
@components/Sidebar.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create custom service worker and update vite.config.ts</name>
  <files>
    sw.ts
    vite.config.ts
  </files>
  <action>
    1. Create `sw.ts` in the project root directory (same level as App.tsx, since there is no `src/` directory in this project):

       ```typescript
       /// <reference lib="webworker" />
       import { cleanupOutdatedCaches, precacheAndRoute } from 'workbox-precaching'
       import { registerRoute } from 'workbox-routing'
       import { NetworkFirst, NetworkOnly } from 'workbox-strategies'
       import { BackgroundSyncPlugin } from 'workbox-background-sync'
       import { clientsClaim } from 'workbox-core'

       declare let self: ServiceWorkerGlobalScope

       // Take control immediately on install/activate
       self.skipWaiting()
       clientsClaim()

       // Clean up old precache entries from previous versions
       cleanupOutdatedCaches()

       // Precache all app shell assets (manifest injected by vite-plugin-pwa at build time)
       precacheAndRoute(self.__WB_MANIFEST)

       // Runtime cache: Supabase API — NetworkFirst with 1 hour expiration
       // Mirrors the existing generateSW runtimeCaching config
       registerRoute(
         ({ url }) => url.hostname.includes('supabase.co'),
         new NetworkFirst({
           cacheName: 'supabase-api',
           networkTimeoutSeconds: 10,
         })
       )

       // Offline review queue: intercept Supabase POST requests for review_logs and study_cards
       // When offline, requests are stored in IndexedDB and replayed when back online
       const reviewSyncPlugin = new BackgroundSyncPlugin('review-queue', {
         maxRetentionTime: 24 * 60, // Retry for up to 24 hours (in minutes)
       })

       // Queue review_logs POST requests when offline
       registerRoute(
         ({ url, request }) =>
           url.hostname.includes('supabase.co') &&
           url.pathname.includes('review_logs') &&
           request.method === 'POST',
         new NetworkOnly({ plugins: [reviewSyncPlugin] }),
         'POST'
       )

       // Queue study_cards PATCH requests when offline (card state updates during study)
       const cardSyncPlugin = new BackgroundSyncPlugin('card-update-queue', {
         maxRetentionTime: 24 * 60,
       })

       registerRoute(
         ({ url, request }) =>
           url.hostname.includes('supabase.co') &&
           url.pathname.includes('study_cards') &&
           request.method === 'PATCH',
         new NetworkOnly({ plugins: [cardSyncPlugin] }),
         'PATCH'
       )

       // Push notification handler placeholder (Phase 18 will implement)
       self.addEventListener('push', (_event) => {
         // Phase 18: Parse push data and show notification
       })

       // Notification click handler placeholder (Phase 18 will implement)
       self.addEventListener('notificationclick', (_event) => {
         // Phase 18: Handle notification click (open app, navigate to study)
       })
       ```

    2. Update `vite.config.ts` — replace the `workbox` key with `injectManifest`:
       - Change `VitePWA({` config:
         - Add `strategies: 'injectManifest'` (was implicit 'generateSW')
         - Add `srcDir: '.'` (project root, since no src/ directory)
         - Add `filename: 'sw.ts'`
         - Add `injectManifest: { globPatterns: ['**/*.{js,css,html,ico,png,svg,woff2}'] }`
         - REMOVE the entire `workbox: { ... }` block (it was for generateSW strategy)
         - Keep `registerType: 'autoUpdate'`
         - Keep `includeAssets` array unchanged
         - Keep `manifest` block unchanged

       The resulting VitePWA config should look like:
       ```typescript
       VitePWA({
         strategies: 'injectManifest',
         srcDir: '.',
         filename: 'sw.ts',
         registerType: 'autoUpdate',
         includeAssets: [
           'favicon-evq/favicon.ico',
           'favicon-evq/favicon.svg',
           'favicon-evq/apple-touch-icon.png',
           'favicon-evq/favicon-96x96.png',
           'favicon-evq/web-app-manifest-192x192.png',
           'favicon-evq/web-app-manifest-512x512.png'
         ],
         manifest: {
           // ... existing manifest (unchanged)
         },
         injectManifest: {
           globPatterns: ['**/*.{js,css,html,ico,png,svg,woff2}'],
         },
       })
       ```

    3. CRITICAL: Verify `self.__WB_MANIFEST` appears in sw.ts — without it, the build will fail with "Could not find injectionPoint".

    4. TypeScript note: The `declare let self: ServiceWorkerGlobalScope` line + `/// <reference lib="webworker" />` triple-slash directive provides typing for the service worker global scope without modifying tsconfig.json. The SW is compiled by Vite (not tsc), so this is sufficient.
  </action>
  <verify>
    - `npm run build` completes WITHOUT the error "Could not find injectionPoint in service worker"
    - Build output includes a service worker file in `dist/` (check `ls dist/sw.js` or similar)
    - No TypeScript errors during build
    - The old `workbox:` config is fully removed from vite.config.ts
  </verify>
  <done>
    Custom service worker sw.ts is created with precaching, NetworkFirst Supabase caching, BackgroundSyncPlugin for offline review queuing, and push notification placeholders. vite.config.ts uses injectManifest strategy. Build succeeds.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create useOnlineStatus hook and add offline indicator to Sidebar</name>
  <files>
    hooks/useOnlineStatus.ts
    components/Sidebar.tsx
  </files>
  <action>
    1. Create `hooks/useOnlineStatus.ts`:
       ```typescript
       import { useState, useEffect } from 'react'

       /**
        * Tracks browser online/offline status via navigator.onLine and events.
        * Returns true when online, false when offline.
        */
       export function useOnlineStatus() {
         const [isOnline, setIsOnline] = useState(navigator.onLine)

         useEffect(() => {
           const handleOnline = () => setIsOnline(true)
           const handleOffline = () => setIsOnline(false)
           window.addEventListener('online', handleOnline)
           window.addEventListener('offline', handleOffline)
           return () => {
             window.removeEventListener('online', handleOnline)
             window.removeEventListener('offline', handleOffline)
           }
         }, [])

         return isOnline
       }
       ```

    2. Update `components/Sidebar.tsx` — add a subtle offline indicator:
       - Import the hook: `import { useOnlineStatus } from '../hooks/useOnlineStatus'`
       - Import `WifiOff` icon from lucide-react (add to existing lucide import)
       - Call the hook inside the Sidebar component: `const isOnline = useOnlineStatus()`
       - Add an offline badge in the header area, after the logo icon slot. When offline, show a small indicator. When expanded, show text "Offline":
         ```tsx
         {/* Offline indicator — only visible when offline */}
         {!isOnline && (
           <div className="flex items-center gap-xs px-xs py-1">
             <div className={ICON_SLOT}>
               <WifiOff className="w-3.5 h-3.5 text-amber-500" />
             </div>
             <span
               className={cn(
                 "text-caption text-amber-500 whitespace-nowrap transition-opacity duration-300",
                 isExpanded ? "opacity-100" : "opacity-0"
               )}
             >
               Offline
             </span>
           </div>
         )}
         ```
       - Place this indicator between the header and the nav section (after the header closing div, before the `<nav>` element). It should appear as a small status bar.
       - The indicator uses `text-amber-500` for a subtle warning color that works in both light and dark modes.
       - When the sidebar is collapsed, only the WifiOff icon is visible (text fades out per the opacity pattern).
       - When online, this entire block is hidden (not rendered).

    **IMPORTANT — Sidebar.tsx parallel edit with Plan 17-01:**
    Plan 17-01 (wave 1) also modifies Sidebar.tsx (adding prefetch on hover). Since both plans are wave 1, the executor MUST read the current state of `components/Sidebar.tsx` before applying changes — do NOT assume the file matches the version in the @context reference. The two plans touch different parts:
    - Plan 01 changes: navItems array (adding `component` field) and NavLink (adding `onMouseEnter`)
    - Plan 03 changes: imports (adding WifiOff, useOnlineStatus) and JSX (adding offline indicator between header and nav)

    **Executor instruction:** At the start of this task, use `Read components/Sidebar.tsx` to get the current file contents. Apply the import additions and JSX changes on top of whatever is currently in the file, whether Plan 01 has already run or not. The changes target non-overlapping regions and should merge cleanly.
  </action>
  <verify>
    - `npm run build` completes without errors
    - `hooks/useOnlineStatus.ts` exports `useOnlineStatus`
    - Sidebar.tsx imports and uses `useOnlineStatus`
    - In Chrome DevTools: Application > Service Workers > check "Offline" toggle — the Sidebar should show the offline indicator
    - Uncheck "Offline" — indicator should disappear
    - Run `npm run preview` (serves built files) — verify the app loads and the service worker is registered (check Application > Service Workers in DevTools)
  </verify>
  <done>
    useOnlineStatus hook detects online/offline state. Sidebar shows a subtle WifiOff icon + "Offline" text when offline. Service worker handles offline caching and review queuing via BackgroundSyncPlugin. Existing offline PWA functionality is preserved (app shell loads from cache, Supabase data from NetworkFirst cache).
  </done>
</task>

</tasks>

<verification>
1. `npm run build` succeeds
2. `npm run preview` — app loads, service worker registers (check DevTools > Application > Service Workers)
3. In DevTools > Application > Service Workers, check "Offline" toggle:
   - App still loads (cached app shell)
   - Sidebar shows offline indicator (WifiOff icon)
   - Navigate between pages (cached routes load)
4. Uncheck "Offline":
   - Offline indicator disappears
   - App fetches fresh data from Supabase
5. Service worker file exists in build output
6. No regression: `npm run build && npm run preview` works end-to-end
</verification>

<success_criteria>
- Custom service worker (injectManifest) replaces auto-generated one
- App shell precached for offline access
- Supabase API uses NetworkFirst caching
- Review submissions queued offline via BackgroundSyncPlugin
- Subtle offline indicator visible in Sidebar when disconnected
- Build succeeds and PWA functionality preserved
</success_criteria>

<output>
After completion, create `.planning/phases/17-performance-foundation/17-03-SUMMARY.md`
</output>

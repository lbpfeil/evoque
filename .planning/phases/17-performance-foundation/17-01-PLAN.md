---
phase: 17-performance-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - pages/lazyPages.ts
  - App.tsx
  - components/Sidebar.tsx
  - pages/Highlights.tsx
  - components/ui/skeleton.tsx
  - hooks/useSkeletonDelay.ts
autonomous: true
requirements: [PERF-01, PERF-04, PERF-05]
must_haves:
  truths:
    - "Hovering a nav link in the sidebar triggers prefetch of that route's bundle"
    - "TagManagerSidebar code is only loaded when the user opens the tag manager"
    - "A reusable Skeleton primitive exists for building page-level skeletons"
    - "The useSkeletonDelay hook implements the 200ms delay, 300ms min display, and content fade-in pattern"
  artifacts:
    - path: "pages/lazyPages.ts"
      provides: "Centralized lazyWithPreload page exports"
      exports: ["Dashboard", "Highlights", "Study", "Settings", "StudySession"]
    - path: "components/ui/skeleton.tsx"
      provides: "Base skeleton primitive component"
      exports: ["Skeleton"]
    - path: "hooks/useSkeletonDelay.ts"
      provides: "Skeleton delay/fade transition hook"
      exports: ["useSkeletonDelay"]
  key_links:
    - from: "App.tsx"
      to: "pages/lazyPages.ts"
      via: "import lazy page components"
      pattern: "import.*from.*lazyPages"
    - from: "components/Sidebar.tsx"
      to: "pages/lazyPages.ts"
      via: "onMouseEnter calls .preload()"
      pattern: "preload\\(\\)"
    - from: "pages/Highlights.tsx"
      to: "components/TagManagerSidebar"
      via: "React.lazy dynamic import"
      pattern: "lazy\\(.*TagManagerSidebar"
---

<objective>
Set up route prefetching on hover, lazy-load heavy modals, and create skeleton building blocks (primitive + delay hook) for use in Plan 02.

Purpose: Establish the code-splitting and skeleton infrastructure that enables faster perceived load times across the app.
Output: lazyPages.ts with preloadable routes, skeleton primitive, useSkeletonDelay hook, lazy TagManagerSidebar, and prefetch on hover in Sidebar.
</objective>

<execution_context>
@C:/Users/ADMIN/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ADMIN/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-performance-foundation/17-RESEARCH.md

@App.tsx
@components/Sidebar.tsx
@pages/Highlights.tsx
@hooks/useSkeletonDelay.ts
@components/ui/skeleton.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install react-lazy-with-preload, create lazyPages module, and wire prefetch into App.tsx + Sidebar</name>
  <files>
    pages/lazyPages.ts
    App.tsx
    components/Sidebar.tsx
    package.json
  </files>
  <action>
    1. Install `react-lazy-with-preload`:
       ```bash
       npm install react-lazy-with-preload
       ```

    2. Create `pages/lazyPages.ts` — centralized lazy page exports (avoids circular dependency between App.tsx and Sidebar.tsx):
       ```typescript
       import { lazyWithPreload } from 'react-lazy-with-preload';

       export const Dashboard = lazyWithPreload(() => import('./Dashboard'));
       export const Highlights = lazyWithPreload(() => import('./Highlights'));
       export const Study = lazyWithPreload(() => import('./Study'));
       export const Settings = lazyWithPreload(() => import('./Settings'));
       export const StudySession = lazyWithPreload(() => import('./StudySession'));
       ```

    3. Update `App.tsx`:
       - Remove the 5 `const X = lazy(...)` lines at the top
       - Import from `pages/lazyPages.ts` instead: `import { Dashboard, Highlights, Study, Settings, StudySession } from './pages/lazyPages'`
       - Remove `Suspense` and `lazy` from the React import (keep `Suspense` — it's still needed for the fallback)
       - Remove `import { Loader2 } from 'lucide-react'` ONLY if `PageLoadingFallback` is the sole user (check: it's also used in ProtectedApp loading state — keep Loader2 import)
       - Keep `PageLoadingFallback` and `Suspense` wrappers exactly as they are — skeleton replacement happens in Plan 02

    4. Update `components/Sidebar.tsx`:
       - Import the lazy page components: `import { Dashboard, Highlights, Study, Settings } from '../pages/lazyPages'`
       - Add a `component` field to each navItem referencing the corresponding lazy component:
         ```typescript
         const navItems = [
           { name: t('nav.dashboard'), icon: LayoutDashboard, path: '/dashboard', component: Dashboard },
           { name: t('nav.study'), icon: Target, path: '/study', component: Study },
           { name: t('nav.highlights'), icon: Highlighter, path: '/highlights', component: Highlights },
           { name: t('nav.settings'), icon: Settings as any, path: '/settings', component: SettingsPage },
         ];
         ```
         NOTE: There is a naming conflict — `Settings` is already imported from lucide-react as an icon. Rename the page import to avoid collision: `import { Dashboard, Highlights, Study, Settings as SettingsPage } from '../pages/lazyPages'`
       - Add `onMouseEnter` to each `NavLink`:
         ```tsx
         <NavLink
           key={item.name}
           to={item.path}
           onMouseEnter={() => item.component?.preload()}
           className={...}
         >
         ```
  </action>
  <verify>
    - `npm run build` completes without errors
    - Check build output for separate chunks per page (look for Dashboard, Highlights, Study, Settings, StudySession chunk files in dist/assets/)
    - Verify `react-lazy-with-preload` is in package.json dependencies
  </verify>
  <done>
    All 5 page routes use `lazyWithPreload` from a centralized module. Sidebar NavLinks call `.preload()` on hover. No circular dependency between App.tsx and Sidebar.tsx. Build succeeds.
  </done>
</task>

<task type="auto">
  <name>Task 2: Lazy-load TagManagerSidebar, create Skeleton primitive and useSkeletonDelay hook</name>
  <files>
    pages/Highlights.tsx
    components/ui/skeleton.tsx
    hooks/useSkeletonDelay.ts
  </files>
  <action>
    1. In `pages/Highlights.tsx`:
       - Remove the static import: `import { TagManagerSidebar } from '../components/TagManagerSidebar'` (line 8)
       - Add lazy import at top of file:
         ```typescript
         import { lazy, Suspense } from 'react';
         const TagManagerSidebar = lazy(() =>
           import('../components/TagManagerSidebar').then(m => ({ default: m.TagManagerSidebar }))
         );
         ```
         (TagManagerSidebar is a named export, so `.then()` wrapper is required)
       - Find where TagManagerSidebar is rendered. Wrap it with Suspense:
         ```tsx
         {isTagManagerOpen && (
           <Suspense fallback={null}>
             <TagManagerSidebar open={isTagManagerOpen} onOpenChange={setIsTagManagerOpen} />
           </Suspense>
         )}
         ```
         The `fallback={null}` is fine because the sidebar has its own open/close animation.
       - Ensure `Suspense` is imported from React (add to the existing React import if needed)

    2. Create `components/ui/skeleton.tsx` — base skeleton primitive following shadcn/ui pattern:
       ```typescript
       import { cn } from '../../lib/utils'

       function Skeleton({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) {
         return (
           <div
             className={cn('animate-pulse rounded-md bg-muted', className)}
             {...props}
           />
         )
       }

       export { Skeleton }
       ```

    3. Create `hooks/useSkeletonDelay.ts` — implements locked decisions (200ms delay, 300ms min display, 150ms content fade):
       ```typescript
       import { useState, useEffect, useRef } from 'react'

       /**
        * Controls skeleton visibility with delay and minimum display time.
        *
        * - Waits `delay` ms before showing skeleton (avoids flash on fast loads)
        * - Once skeleton appears, shows it for at least `minDisplay` ms
        * - Returns `showContent` for fade-in transition (150ms CSS transition)
        *
        * Usage:
        *   const { showSkeleton, showContent } = useSkeletonDelay(isLoaded)
        *   if (showSkeleton) return <PageSkeleton />
        *   return <div className={showContent ? 'animate-in fade-in duration-150' : 'opacity-0'}>...</div>
        */
       export function useSkeletonDelay(isLoaded: boolean, delay = 200, minDisplay = 300) {
         const [showSkeleton, setShowSkeleton] = useState(false)
         const [showContent, setShowContent] = useState(false)
         const skeletonShownAt = useRef<number | null>(null)

         useEffect(() => {
           if (isLoaded) {
             // Data is loaded
             if (skeletonShownAt.current) {
               // Skeleton was visible — ensure minimum display time
               const elapsed = Date.now() - skeletonShownAt.current
               const remaining = Math.max(0, minDisplay - elapsed)
               const timer = setTimeout(() => {
                 setShowSkeleton(false)
                 setShowContent(true)
               }, remaining)
               return () => clearTimeout(timer)
             } else {
               // Data loaded before delay — skip skeleton entirely
               setShowSkeleton(false)
               setShowContent(true)
             }
           } else {
             // Data not loaded — start delay timer
             setShowContent(false)
             const timer = setTimeout(() => {
               setShowSkeleton(true)
               skeletonShownAt.current = Date.now()
             }, delay)
             return () => clearTimeout(timer)
           }
         }, [isLoaded, delay, minDisplay])

         return { showSkeleton, showContent }
       }
       ```
       This hook is critical for the locked transition decisions. The logic:
       - If `isLoaded` becomes true before 200ms: no skeleton shown, content appears immediately
       - If `isLoaded` becomes true after skeleton appeared: skeleton stays for at least 300ms total, then content fades in
       - `showContent` drives a 150ms CSS `animate-in fade-in` transition (from tailwindcss-animate, already installed)
  </action>
  <verify>
    - `npm run build` completes without errors
    - Verify `components/ui/skeleton.tsx` exports `Skeleton`
    - Verify `hooks/useSkeletonDelay.ts` exports `useSkeletonDelay`
    - Verify TagManagerSidebar is no longer in the main Highlights chunk (check build output for a separate chunk containing TagManagerSidebar)
  </verify>
  <done>
    TagManagerSidebar loads lazily only when opened. Skeleton primitive exists for composing page skeletons. useSkeletonDelay hook correctly implements 200ms/300ms/150ms transition pattern per locked decisions.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` succeeds with no errors
2. Build output in `dist/assets/` shows separate chunks for each lazy-loaded page
3. TagManagerSidebar is in its own chunk (not bundled with Highlights)
4. `react-lazy-with-preload` is in package.json
5. No circular dependencies between App.tsx and Sidebar.tsx (both import from lazyPages.ts)
</verification>

<success_criteria>
- All route components use lazyWithPreload and are prefetched on hover in Sidebar
- TagManagerSidebar is lazy-loaded on demand
- Skeleton primitive and useSkeletonDelay hook exist and are ready for Plan 02 to use
- Build succeeds and produces separate chunks per route
</success_criteria>

<output>
After completion, create `.planning/phases/17-performance-foundation/17-01-SUMMARY.md`
</output>

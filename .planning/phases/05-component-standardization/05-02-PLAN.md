---
phase: 05-component-standardization
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - components/patterns/PageHeader.tsx
  - components/patterns/DataTable.tsx
autonomous: true

must_haves:
  truths:
    - "PageHeader renders consistent title/description/actions layout for any page"
    - "PageHeader size='default' uses text-title (30px) for destination pages (Dashboard, Highlights)"
    - "PageHeader size='compact' uses text-heading (18px) for tool pages (Study, Settings)"
    - "DataTable renders a table with header, rows, hover states, and click handlers from column definitions"
    - "DataTable matches DeckTable's visual patterns (border, muted header, hover, divide-y)"
  artifacts:
    - path: "components/patterns/PageHeader.tsx"
      provides: "Canonical page header composition component"
      exports: ["PageHeader"]
      min_lines: 25
    - path: "components/patterns/DataTable.tsx"
      provides: "Generic data table pattern component"
      exports: ["DataTable"]
      min_lines: 40
  key_links:
    - from: "components/patterns/PageHeader.tsx"
      to: "tailwind.config.js"
      via: "text-title, text-heading token classes"
      pattern: "text-title|text-heading"
    - from: "components/patterns/DataTable.tsx"
      to: "components/DeckTable.tsx"
      via: "same visual patterns (border, hover, divide-y)"
      pattern: "border-border.*hover:bg-accent"
---

<objective>
Create two canonical composition patterns: PageHeader for consistent page layout headers, and DataTable for reusable table structures.

Purpose: Eliminate copy-pasted header markup across pages and provide a reusable table pattern based on the proven DeckTable structure. These components will be consumed in Phase 6 (Page Migration) when all pages are migrated to canonical patterns.

Output: Two new files in components/patterns/ directory.
</objective>

<execution_context>
@C:\Users\lbp80\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\lbp80\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@components/DeckTable.tsx
@.planning/phases/05-component-standardization/05-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PageHeader composition component</name>
  <files>components/patterns/PageHeader.tsx</files>
  <action>
Create directory `components/patterns/` if it doesn't exist, then create PageHeader.tsx.

The component must:

1. Accept props:
   - `title: string` (required)
   - `description?: string` (optional subtitle)
   - `actions?: React.ReactNode` (optional action buttons area, right-aligned)
   - `size?: 'default' | 'compact'` (default = 'default')
   - `className?: string` (optional additional classes on root element)

2. Render structure:
```
<header className={cn('mb-lg', size === 'compact' && 'mb-md', className)}>
  <div className="flex items-start justify-between gap-md">
    <div>
      <h1 className={cn(
        'font-bold text-foreground tracking-tight',
        size === 'default' ? 'text-title' : 'text-heading'
      )}>
        {title}
      </h1>
      {description && (
        <p className={cn(
          'text-muted-foreground mt-xs',
          size === 'default' ? 'text-body' : 'text-caption'
        )}>
          {description}
        </p>
      )}
    </div>
    {actions && <div className="flex-shrink-0">{actions}</div>}
  </div>
</header>
```

3. Use token classes exclusively:
   - `text-title` (30px) for default size title (NOT text-3xl)
   - `text-heading` (18px) for compact size title (NOT text-base)
   - `text-body` (14px) for default description (NOT text-sm)
   - `text-caption` (12px) for compact description (NOT text-xs)
   - `mb-lg` (24px) for default bottom margin (NOT mb-6)
   - `mb-md` (16px) for compact bottom margin (NOT mb-3 or mb-4)
   - `gap-md` (16px) for flex gap (NOT gap-4)
   - `mt-xs` (4px) for description top margin (NOT mt-1)

4. Import `cn` from `'../../lib/utils'` (relative path, matching codebase convention for non-UI components).

5. Export as named export: `export function PageHeader(...)`.

6. Define PageHeaderProps interface and export it.

WHY these token mappings: Phase 4 defined text-title=30px (replaces text-3xl on Dashboard/Highlights), text-heading=18px (replaces text-base on Study/Settings). Using token classes ensures the PageHeader renders consistently with the design system. mb-lg replaces the inconsistent mb-6/mb-3 patterns.

WHY size='default' maps to text-title: Dashboard and Highlights are "destination" pages where users spend time. Larger titles make them feel important. Study and Settings are "tool" pages where compact headers save space for content.
  </action>
  <verify>
Run `npm run build` and confirm no TypeScript errors.
Verify the file exists at components/patterns/PageHeader.tsx.
Verify it exports PageHeader and PageHeaderProps.
  </verify>
  <done>PageHeader component exists with size='default' (text-title, 30px) and size='compact' (text-heading, 18px) variants. Uses token classes exclusively. Exported as named export with TypeScript interface.</done>
</task>

<task type="auto">
  <name>Task 2: Create DataTable composition pattern</name>
  <files>components/patterns/DataTable.tsx</files>
  <action>
Create DataTable.tsx in components/patterns/.

The component must generalize the DeckTable pattern with these features ONLY (YAGNI -- no sorting, filtering, pagination):

1. Define interfaces:
```typescript
interface Column<T> {
  key: string
  header: string
  render: (item: T) => React.ReactNode
  className?: string
  headerClassName?: string
}

interface DataTableProps<T> {
  columns: Column<T>[]
  data: T[]
  onRowClick?: (item: T) => void
  gridCols: string           // e.g., "grid-cols-[1fr_48px]"
  gridColsSm?: string        // optional responsive override, e.g., "sm:grid-cols-[1fr_48px_64px_48px_48px]"
  rowClassName?: (item: T) => string | undefined  // conditional row styles (e.g., isAllBooks bold)
  emptyMessage?: string      // message when data is empty
}
```

2. Render structure (match DeckTable exactly):
```
<div className="border border-border rounded overflow-hidden">
  {/* Header */}
  <div className={cn(
    'bg-muted border-b border-border px-sm py-xs grid gap-sm items-center',
    gridCols,
    gridColsSm
  )}>
    {columns.map(col => (
      <div
        key={col.key}
        className={cn('text-caption font-semibold text-muted-foreground', col.headerClassName)}
      >
        {col.header}
      </div>
    ))}
  </div>

  {/* Body */}
  <div className="divide-y divide-border">
    {data.length === 0 && emptyMessage ? (
      <div className="px-sm py-md text-caption text-muted-foreground text-center">
        {emptyMessage}
      </div>
    ) : (
      data.map((item, index) => {
        const Row = onRowClick ? 'button' : 'div'
        return (
          <Row
            key={index}
            onClick={onRowClick ? () => onRowClick(item) : undefined}
            className={cn(
              'w-full px-sm py-xs grid gap-sm items-center',
              gridCols,
              gridColsSm,
              onRowClick && 'hover:bg-accent/50 transition-colors text-left cursor-pointer',
              rowClassName?.(item)
            )}
          >
            {columns.map(col => (
              <div key={col.key} className={col.className}>
                {col.render(item)}
              </div>
            ))}
          </Row>
        )
      })
    )}
  </div>
</div>
```

3. Use token spacing classes:
   - `px-sm` (8px) instead of `px-2`
   - `py-xs` (4px) instead of `py-1`
   - `gap-sm` (8px) instead of `gap-2`
   - `py-md` (16px) for empty state vertical padding
   - `text-caption` (12px) instead of `text-xs`

4. Export as named export with generics: `export function DataTable<T>(...)`

5. Export Column and DataTableProps interfaces.

6. Import `cn` from `'../../lib/utils'`.

CONSTRAINTS:
- DO NOT add sorting, filtering, or pagination. YAGNI.
- DO NOT exceed 80 lines. DeckTable is 97 lines including app-specific logic. DataTable should be simpler.
- DO NOT use React.FC (use plain function with generics for proper generic inference).
- The `key` for rows uses index because the generic T has no guaranteed id field. Consumers can pass keyed data.

WHY gridCols as string prop: DeckTable uses complex responsive grid definitions like `grid-cols-[1fr_48px] sm:grid-cols-[1fr_48px_64px_48px_48px]`. Encoding this as a type-safe system would be over-engineering. A string prop gives full flexibility.

WHY rowClassName as function: DeckTable has conditional row styling (`deck.isAllBooks && "bg-muted/50 font-medium"`). A function prop allows consumers to apply per-row styles based on data.
  </action>
  <verify>
Run `npm run build` and confirm no TypeScript errors.
Verify the file exists at components/patterns/DataTable.tsx.
Verify it exports DataTable, Column, and DataTableProps.
Verify it does NOT exceed 80 lines.
  </verify>
  <done>DataTable component exists with Column/DataTableProps interfaces. Renders header, body with hover, dividers. Uses token spacing classes. Under 80 lines. No sorting/filtering/pagination (YAGNI). Exported as generic function.</done>
</task>

</tasks>

<verification>
1. `npm run build` succeeds with no new errors or warnings
2. `components/patterns/PageHeader.tsx` exists and exports PageHeader
3. `components/patterns/DataTable.tsx` exists and exports DataTable
4. PageHeader uses `text-title` and `text-heading` token classes (not raw Tailwind sizes)
5. DataTable visual patterns match DeckTable (border, muted header, hover, divide-y)
6. DataTable is under 80 lines
7. No raw Tailwind sizes in either component (no text-3xl, text-base, text-xs, etc.)
</verification>

<success_criteria>
- PageHeader component with default/compact size variants using token classes
- DataTable generic component matching DeckTable's visual patterns
- Both exported as named exports with TypeScript interfaces
- `npm run build` passes
- Both components ready for Phase 6 consumption (no page imports yet)
</success_criteria>

<output>
After completion, create `.planning/phases/05-component-standardization/05-02-SUMMARY.md`
</output>

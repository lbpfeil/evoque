---
phase: 14-settings-audit
plan: 03
type: execute
wave: 2
depends_on: [14-01, 14-02]
files_modified:
  - services/sm2.test.ts
  - lib/settingsLogic.ts
  - lib/settingsLogic.test.ts
autonomous: true

must_haves:
  truths:
    - "SM-2 algorithm tests pass for all quality ratings (1-4)"
    - "SM-2 algorithm tests verify ease factor bounds (1.3-2.5)"
    - "Settings cascade tests verify priority: book > global > default"
    - "Daily limit logic tests verify correct remaining card calculation"
  artifacts:
    - path: "services/sm2.test.ts"
      provides: "Unit tests for SM-2 algorithm"
      contains: "calculateNextReview"
    - path: "lib/settingsLogic.ts"
      provides: "Extracted pure functions for settings cascade"
      exports: ["getDailyLimit", "getEaseFactor", "getRemainingReviews"]
    - path: "lib/settingsLogic.test.ts"
      provides: "Unit tests for settings logic"
      contains: "getDailyLimit"
  key_links:
    - from: "lib/settingsLogic.test.ts"
      to: "lib/settingsLogic.ts"
      via: "import"
      pattern: "import.*settingsLogic"
    - from: "services/sm2.test.ts"
      to: "services/sm2.ts"
      via: "import"
      pattern: "import.*sm2"
---

<objective>
Write automated tests for SM-2 algorithm and settings logic to satisfy SETT-03.

Purpose: Ensure critical study logic is tested and won't regress (SETT-03).
Output: Passing test suite covering SM-2 and settings cascade.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-settings-audit/14-RESEARCH.md
@.planning/phases/14-settings-audit/14-01-SUMMARY.md
@.planning/phases/14-settings-audit/14-02-SUMMARY.md

@services/sm2.ts
@lib/constants.ts
@types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write SM-2 algorithm unit tests</name>
  <files>services/sm2.test.ts</files>
  <action>
    Create `services/sm2.test.ts` with comprehensive tests for calculateNextReview:

    ```typescript
    import { describe, it, expect, beforeEach, vi, afterEach } from 'vitest';
    import { calculateNextReview, initializeCard } from './sm2';
    import type { StudyCard } from '../types';

    describe('SM-2 Algorithm', () => {
      let baseCard: StudyCard;

      beforeEach(() => {
        vi.useFakeTimers();
        vi.setSystemTime(new Date('2026-01-30T12:00:00'));

        baseCard = {
          id: 'test-card',
          highlightId: 'test-highlight',
          easeFactor: 2.5,
          interval: 0,
          repetitions: 0,
          nextReviewDate: new Date().toISOString()
        };
      });

      afterEach(() => {
        vi.useRealTimers();
      });

      describe('quality 1 (Again)', () => {
        it('resets repetitions to 0', () => {
          const card = { ...baseCard, repetitions: 3 };
          const result = calculateNextReview(card, 1);
          expect(result.repetitions).toBe(0);
        });

        it('sets interval to 1 day', () => {
          const result = calculateNextReview(baseCard, 1);
          expect(result.interval).toBe(1);
        });

        it('preserves ease factor', () => {
          const card = { ...baseCard, easeFactor: 2.0 };
          const result = calculateNextReview(card, 1);
          expect(result.easeFactor).toBe(2.0);
        });
      });

      describe('quality 2 (Hard)', () => {
        it('increments repetitions', () => {
          const result = calculateNextReview(baseCard, 2);
          expect(result.repetitions).toBe(1);
        });

        it('sets interval to 1 on first review', () => {
          const result = calculateNextReview(baseCard, 2);
          expect(result.interval).toBe(1);
        });

        it('sets interval to 3 on second review (shorter than Good)', () => {
          const card = { ...baseCard, repetitions: 1, interval: 1 };
          const result = calculateNextReview(card, 2);
          expect(result.interval).toBe(3);
        });

        it('decreases ease factor by 0.15', () => {
          const result = calculateNextReview(baseCard, 2);
          expect(result.easeFactor).toBe(2.35);
        });
      });

      describe('quality 3 (Good)', () => {
        it('increments repetitions', () => {
          const result = calculateNextReview(baseCard, 3);
          expect(result.repetitions).toBe(1);
        });

        it('sets interval to 1 on first review', () => {
          const result = calculateNextReview(baseCard, 3);
          expect(result.interval).toBe(1);
        });

        it('sets interval to 6 on second review', () => {
          const card = { ...baseCard, repetitions: 1, interval: 1 };
          const result = calculateNextReview(card, 3);
          expect(result.interval).toBe(6);
        });

        it('keeps ease factor unchanged', () => {
          const result = calculateNextReview(baseCard, 3);
          expect(result.easeFactor).toBe(2.5);
        });
      });

      describe('quality 4 (Easy)', () => {
        it('increments repetitions', () => {
          const result = calculateNextReview(baseCard, 4);
          expect(result.repetitions).toBe(1);
        });

        it('increases ease factor by 0.15 (capped at 2.5)', () => {
          const card = { ...baseCard, easeFactor: 2.3 };
          const result = calculateNextReview(card, 4);
          expect(result.easeFactor).toBe(2.45);
        });
      });

      describe('ease factor bounds', () => {
        it('does not go below 1.3', () => {
          const card = { ...baseCard, easeFactor: 1.4 };
          const result = calculateNextReview(card, 2);
          expect(result.easeFactor).toBe(1.3);
        });

        it('does not exceed 2.5', () => {
          const card = { ...baseCard, easeFactor: 2.45 };
          const result = calculateNextReview(card, 4);
          expect(result.easeFactor).toBe(2.5);
        });
      });

      describe('next review date', () => {
        it('sets next review date to current date + interval days', () => {
          const card = { ...baseCard, repetitions: 1, interval: 1 };
          const result = calculateNextReview(card, 3);
          // interval becomes 6, so next review is 6 days from now
          const expectedDate = new Date('2026-02-05T12:00:00');
          expect(new Date(result.nextReviewDate).toDateString()).toBe(expectedDate.toDateString());
        });
      });
    });

    describe('initializeCard', () => {
      it('creates card with correct highlightId', () => {
        const card = initializeCard('highlight-123');
        expect(card.highlightId).toBe('highlight-123');
      });

      it('creates card with default ease factor of 2.5', () => {
        const card = initializeCard('highlight-123');
        expect(card.easeFactor).toBe(2.5);
      });

      it('creates card with 0 repetitions and interval', () => {
        const card = initializeCard('highlight-123');
        expect(card.repetitions).toBe(0);
        expect(card.interval).toBe(0);
      });

      it('generates unique ID', () => {
        const card = initializeCard('highlight-123');
        expect(card.id).toBeTruthy();
        expect(typeof card.id).toBe('string');
      });
    });
    ```
  </action>
  <verify>
    - `npm test -- --run services/sm2.test.ts` runs and all tests pass
    - Test output shows all SM-2 scenarios covered
  </verify>
  <done>SM-2 algorithm has comprehensive unit tests</done>
</task>

<task type="auto">
  <name>Task 2: Extract and test settings cascade logic</name>
  <files>lib/settingsLogic.ts, lib/settingsLogic.test.ts</files>
  <action>
    1. Create `lib/settingsLogic.ts` with pure functions extracted from StoreContext:

    ```typescript
    import { DEFAULT_DAILY_LIMIT, DEFAULT_EASE_FACTOR } from './constants';
    import type { Book, UserSettings, DailyProgress } from '../types';

    /**
     * Get the daily review limit for a specific book.
     * Priority: book setting > global setting > default
     */
    export function getDailyLimit(
      book: Book | null | undefined,
      settings: UserSettings
    ): number {
      return book?.settings?.dailyReviewLimit
        || settings.maxReviewsPerDay
        || DEFAULT_DAILY_LIMIT;
    }

    /**
     * Get the initial ease factor for a specific book.
     * Priority: book setting > global setting > default
     */
    export function getEaseFactor(
      book: Book | null | undefined,
      settings: UserSettings
    ): number {
      return book?.settings?.initialEaseFactor
        || settings.defaultInitialEaseFactor
        || DEFAULT_EASE_FACTOR;
    }

    /**
     * Get remaining reviews for a book today.
     */
    export function getRemainingReviews(
      bookId: string,
      book: Book | null | undefined,
      settings: UserSettings,
      dailyProgress: DailyProgress
    ): number {
      const dailyLimit = getDailyLimit(book, settings);
      const reviewsToday = dailyProgress.bookReviews[bookId] || 0;
      return Math.max(0, dailyLimit - reviewsToday);
    }

    /**
     * Check if daily limit is reached for a book.
     */
    export function isDailyLimitReached(
      bookId: string,
      book: Book | null | undefined,
      settings: UserSettings,
      dailyProgress: DailyProgress
    ): boolean {
      return getRemainingReviews(bookId, book, settings, dailyProgress) === 0;
    }
    ```

    2. Create `lib/settingsLogic.test.ts`:

    ```typescript
    import { describe, it, expect } from 'vitest';
    import {
      getDailyLimit,
      getEaseFactor,
      getRemainingReviews,
      isDailyLimitReached
    } from './settingsLogic';
    import { DEFAULT_DAILY_LIMIT, DEFAULT_EASE_FACTOR } from './constants';
    import type { Book, UserSettings, DailyProgress } from '../types';

    describe('Settings Cascade Logic', () => {
      const defaultSettings: UserSettings = {
        maxReviewsPerDay: 15,
        newCardsPerDay: 10,
        defaultInitialEaseFactor: 2.3
      };

      const bookWithSettings: Book = {
        id: 'book-1',
        title: 'Test Book',
        author: 'Test Author',
        highlightCount: 10,
        settings: {
          dailyReviewLimit: 5,
          initialEaseFactor: 2.0
        }
      };

      const bookWithoutSettings: Book = {
        id: 'book-2',
        title: 'Another Book',
        author: 'Another Author',
        highlightCount: 5
      };

      describe('getDailyLimit', () => {
        it('returns book setting when present', () => {
          expect(getDailyLimit(bookWithSettings, defaultSettings)).toBe(5);
        });

        it('returns global setting when book has no override', () => {
          expect(getDailyLimit(bookWithoutSettings, defaultSettings)).toBe(15);
        });

        it('returns default when book is null and global not set', () => {
          const emptySettings: UserSettings = { maxReviewsPerDay: 0, newCardsPerDay: 10 };
          expect(getDailyLimit(null, emptySettings)).toBe(DEFAULT_DAILY_LIMIT);
        });

        it('returns default when book is undefined', () => {
          const emptySettings: UserSettings = { maxReviewsPerDay: 0, newCardsPerDay: 10 };
          expect(getDailyLimit(undefined, emptySettings)).toBe(DEFAULT_DAILY_LIMIT);
        });
      });

      describe('getEaseFactor', () => {
        it('returns book setting when present', () => {
          expect(getEaseFactor(bookWithSettings, defaultSettings)).toBe(2.0);
        });

        it('returns global setting when book has no override', () => {
          expect(getEaseFactor(bookWithoutSettings, defaultSettings)).toBe(2.3);
        });

        it('returns default when both book and global not set', () => {
          const emptySettings: UserSettings = { maxReviewsPerDay: 10, newCardsPerDay: 10 };
          expect(getEaseFactor(null, emptySettings)).toBe(DEFAULT_EASE_FACTOR);
        });
      });

      describe('getRemainingReviews', () => {
        const dailyProgress: DailyProgress = {
          date: '2026-01-30',
          bookReviews: {
            'book-1': 3,
            'book-2': 10
          }
        };

        it('calculates remaining based on book limit', () => {
          // Book limit is 5, done 3, remaining is 2
          expect(getRemainingReviews('book-1', bookWithSettings, defaultSettings, dailyProgress)).toBe(2);
        });

        it('calculates remaining based on global limit when no book setting', () => {
          // Global limit is 15, done 10, remaining is 5
          expect(getRemainingReviews('book-2', bookWithoutSettings, defaultSettings, dailyProgress)).toBe(5);
        });

        it('returns 0 when limit exceeded (not negative)', () => {
          const progressOverLimit: DailyProgress = {
            date: '2026-01-30',
            bookReviews: { 'book-1': 10 }
          };
          // Book limit is 5, done 10, remaining is 0 (not -5)
          expect(getRemainingReviews('book-1', bookWithSettings, defaultSettings, progressOverLimit)).toBe(0);
        });

        it('returns full limit when no progress for book', () => {
          const emptyProgress: DailyProgress = { date: '2026-01-30', bookReviews: {} };
          expect(getRemainingReviews('book-1', bookWithSettings, defaultSettings, emptyProgress)).toBe(5);
        });
      });

      describe('isDailyLimitReached', () => {
        it('returns true when limit exactly reached', () => {
          const progress: DailyProgress = {
            date: '2026-01-30',
            bookReviews: { 'book-1': 5 }
          };
          expect(isDailyLimitReached('book-1', bookWithSettings, defaultSettings, progress)).toBe(true);
        });

        it('returns true when limit exceeded', () => {
          const progress: DailyProgress = {
            date: '2026-01-30',
            bookReviews: { 'book-1': 10 }
          };
          expect(isDailyLimitReached('book-1', bookWithSettings, defaultSettings, progress)).toBe(true);
        });

        it('returns false when under limit', () => {
          const progress: DailyProgress = {
            date: '2026-01-30',
            bookReviews: { 'book-1': 3 }
          };
          expect(isDailyLimitReached('book-1', bookWithSettings, defaultSettings, progress)).toBe(false);
        });

        it('returns false when no reviews done', () => {
          const progress: DailyProgress = { date: '2026-01-30', bookReviews: {} };
          expect(isDailyLimitReached('book-1', bookWithSettings, defaultSettings, progress)).toBe(false);
        });
      });
    });
    ```
  </action>
  <verify>
    - `npm test -- --run lib/settingsLogic.test.ts` runs and all tests pass
    - Test output shows all cascade scenarios covered
  </verify>
  <done>Settings cascade logic extracted to pure functions with comprehensive tests</done>
</task>

<task type="auto">
  <name>Task 3: Run full test suite and verify coverage</name>
  <files>None (verification only)</files>
  <action>
    Run the complete test suite and verify:

    1. Run all tests:
       ```bash
       npm test -- --run
       ```

    2. Run with coverage:
       ```bash
       npm run test:coverage
       ```

    3. Verify results:
       - All tests pass (0 failures)
       - SM-2 tests cover all quality ratings
       - Settings logic tests cover all cascade scenarios
       - Coverage for services/sm2.ts and lib/settingsLogic.ts should be high (>80%)

    If any tests fail, debug and fix them before completing this task.
  </action>
  <verify>
    - `npm test -- --run` exits with 0 (all tests pass)
    - Test output shows 15+ tests passing
    - No test failures or errors
  </verify>
  <done>All tests pass, critical settings and SM-2 logic is covered</done>
</task>

</tasks>

<verification>
1. `npm test -- --run` passes with all tests green
2. `services/sm2.test.ts` exists with 10+ test cases
3. `lib/settingsLogic.ts` exists with pure functions
4. `lib/settingsLogic.test.ts` exists with 10+ test cases
5. Test coverage shows services/sm2.ts and lib/settingsLogic.ts covered
</verification>

<success_criteria>
- SM-2 algorithm fully tested (all quality ratings, bounds)
- Settings cascade logic extracted and tested (book > global > default)
- Daily limit calculations tested (remaining, limit reached)
- All tests pass consistently
- Coverage for critical logic files >80%
</success_criteria>

<output>
After completion, create `.planning/phases/14-settings-audit/14-03-SUMMARY.md`
</output>
